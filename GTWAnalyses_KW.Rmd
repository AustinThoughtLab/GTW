---
title: "GTW Analyses"
author: "KWilliams"
date: "12/11/2020"
output: html_document
---

1. Load packages
```{r, echo = FALSE}
library(tidyverse)
library(nloptr) #needed in order to call lme4
library(lme4)
library(ggplot2)
library(reshape2)
library(ggpubr)
library(dplyr)
library(rstatix)
library(car)
```

2. Read in the German language data
```{r}
#Note that 999 indicates missing data
d.g <- read.csv('german_12112019.csv')
d.g <- d.g %>%      
  select(-dob, -dot, -agedays, -agemonths, -monolingual, -comments, -X, -X.1, -X.2, -X.3, -X.4) %>% #remove unnecessary columns
  mutate(language = 'german',
        linenum = ifelse(item=="lastyear", 3, linenum)) # there appears to be an error where this item was incorrectly attributed to line 4

#replace missing data and empty cells with NA
d.g[d.g == "999"] <- NA 
d.g[d.g == ""] <- NA

#aggregate response1 and response2 columns
d.g <- d.g %>%
mutate(response = ifelse(is.na(response2) == T, response1, response2))
```

3. Read in the English language data
```{r}
#Note that 999 indicates missing data
d.e <- read.csv('data_austin.csv')
d.e <- d.e %>%
  #remove unnecessary columns
  select(-ID,-dob, -dot, -agedays, -monolingual, -site, -covered, -comments, -experimenter) %>%
  mutate(language = 'english')

#replace missing data and empty cells with NA
d.e[d.e == "999"] <- NA 
d.e[d.e == ""] <- NA

#aggregate response1 and response2 columns
d.e <- d.e %>%
mutate(response = ifelse(is.na(response2) == T, response1, response2))

```

4. Combine German and English data and fix typos in data entry and re-code weekday (1-7 corresponds to Sun-Sat)
```{r}
d.all <- rbind(d.g, d.e) %>% 
  mutate(item = as.factor(item),
         item = recode_factor(item, 'morning ' = 'thismorning',
                                      'twodaysago' = 'beforeyesterday', 
                                      'dayokweek' = 'daysofweek',
                                      'last year' = 'lastyear',
                                      'twofromnow' = 'aftertomorrow',
                                      'twoago' = 'beforeyesterday',
                                      'inaday' = 'tomorrow',
                                      'dayago' = 'yesterday',
                                      'onedayfromnow' = 'tomorrow',
                                      'thisevening' = 'tonight'),
        language = as.factor(language),
        itemnum = as.factor(itemnum),
        exclude = replace_na(exclude, 0))

d.all$weekday <- ifelse(d.all$weekday == "1", 7, ifelse(d.all$weekday == "2", 1, ifelse(d.all$weekday == "3", 2, ifelse(d.all$weekday == "4", 3, ifelse(d.all$weekday == "5", 4, ifelse(d.all$weekday == "6", 5, ifelse(d.all$weekday == "7", 6, 999)))))))
        #the weekday function in excel codes everything as 1-7 from Sun-Sat so here I am just re-coding so the              variable levels match our calendar task (e.g., 1-7 from Mon-Sun)

#replace missing data with NA
d.all$weekday[d.all$weekday == "999"] <- NA 
```

5. Code all future time words
```{r}
future.words = c('aftertoday','aftertomorrow','dinner','nextbday','nextweek','nextyear','tomorrow','tonight') 
```

6. Code correct responses (to compare to correctr variable) [Is there an easier way to do this?!]
```{r}
d.all <- d.all %>%
  mutate(correctR = case_when(task == "calendar" & itemtype == "deictic" & item == "yesterday" ~ '3',
                              task == "calendar" & itemtype == "deictic" & item == "beforeyesterday" ~ '2',
                              task == "calendar" & itemtype == "deictic" & item == "tomorrow" ~ '5',
                              task == "calendar" & itemtype == "deictic" & item == "aftertomorrow" ~ '6',
                              task == "calendar" & itemtype == "verbal" & item == "aftertoday" ~ '1',
                              task == "calendar" & itemtype == "verbal" & item == "beforetoday" ~ '2',
                              task == "calendar" & itemtype == "verbal" & item == "daysofweek" ~ '7',
                              #assuming a 1 indicates that the child correctly identified all 7 days of the week
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "1" ~ "1",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "2" ~ "2",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "3" ~ "3",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "4" ~ "4",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "5" ~ "5",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "6" ~ "6",
                              task == "calendar" & itemtype == "verbal" & item == "today" & weekday == "7" ~ "7",
                              #remember that weekday values range from 1-7 and correspond to days of the week (e.g.,                               Sunday = 1, Monday = 2, etc.)
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "1" ~ '7',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "2" ~ '1',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "3" ~ '2',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "4" ~ '3',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "5" ~ '4',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "6" ~ '5',
                              task == "calendar" & itemtype =="verbal" & item =="yesterday" & weekday == "7" ~ '6',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "1" ~ '2',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "2" ~ '3',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "3" ~ '4',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "4" ~ '5',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "5" ~ '6',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "6" ~ '7',
                              task == "calendar" & itemtype =="verbal" & item =="tomorrow" & weekday == "7" ~ '1',
                              task == "timeline" & linenum == "1" & item == "lastbday" ~ '1',
                              task == "timeline" & linenum == "1" & item == "breakfast" ~ '2',
                              task == "timeline" & linenum == "1" & item == "dinner" ~ '3', 
                              task == "timeline" & linenum == "1" & item == "nextbday" ~ '4',
                              task == "timeline" & linenum == "2" & item == "lastweek" ~ '1',
                              task == "timeline" & linenum == "2" & item == "thismorning" ~ '2',
                              task == "timeline" & linenum == "2" & item == "tonight" ~ '3',
                              task == "timeline" & linenum == "2" & item == "tomorrow" ~ '4',
                              task == "timeline" & linenum == "3" & item == "lastyear" ~ '1',
                              task == "timeline" & linenum == "3" & item == "yesterday" ~ '2',
                              task == "timeline" & linenum == "3" & item == "nextweek" ~ '3',
                              task == "timeline" & linenum == "3" & item == "nextyear" ~ '4',
                              task == "timeline" & linenum == "4" & item == "beforeyesterday" ~ '1',
                              task == "timeline" & linenum == "4" & item == "yesterday" ~ '2',
                              task == "timeline" & linenum == "4" & item == "tomorrow" ~ '3',
                              task == "timeline" & linenum == "4" & item == "aftertomorrow" ~ '4'))
##seems to match correctr variable that already exists in the data file with two exceptions: verbal 'beforetoday' and 'aftertoday' are coded as indicated on the paper coding sheet e.g., 1 or 0.

check <- d.all %>%
  mutate(matchR = ifelse(correctr == correctR, 'YES', 'NO')) %>%
  filter(matchR == 'NO')   ## 69 mismatches, mostly on verbal Q's, in other cases correctR seems to be correct

```

7. Exclusions, change format of variables from factors to numeric and vice versa, create new variables to code correct responses and deictic status of responses on both the calendar and timeline task
```{r}
d.all <- d.all %>%
  filter(exclude==0) %>%
  mutate(response = as.numeric(response),
         correctR = as.numeric(correctR),
         order = as.factor(order),
         agegroup = as.factor(agegroup),
         linenum = as.factor(linenum),
         #create variable and code whether the item was placed in the correct rank (timeline task) or box (calendar task)
         correct = ifelse(response == correctR, 1, 0),
         #create variable to quantify how far the rank/box placement was from the correct rank/box
         dist.error = correctR - response,
         #create variable ignoring the direction of the error
         dist.error.a = abs(dist.error),
         #create variable and code whether the item was placed in the future (diectic status of response)
         resp.stat = case_when(task=='timeline' & distfrommid > 0 ~ 1,
                                 task=='calendar' & response > 4 ~ 1,
                                 task=='verbal' & item == 'today' & response > correctR ~ 1, 
                               TRUE ~ 0), # "what day will it be yesterday/today/tomorrow etc. e.g., Wednesday would be coded as 3"
         #create variable and code whether the items correct placement is in the future
         item.stat = ifelse(item %in% future.words, 1, 0),
         #create variable and code whether the participant correctly placed the item in the past vs. future
         stat.correct = ifelse(item.stat == resp.stat, 1, 0))
```

8. Participant counts
```{r}
subs <- d.all %>%
  select(subjid, agegroup, language) %>%
  group_by(agegroup, language) %>%
  distinct
subs_counts <- subs %>%
  group_by(agegroup, language) %>%
  summarize(n())
```

9. Calendar task only 
```{r}
cal.d <- d.all %>%
  filter(task=="calendar" & itemtype=="deictic" & agegroup %in% c('4','5','6') & ageyears<7.0) %>% #filter only calendar items that are marked as deictic (verbal items not involved in the calendar task)
  select(-linelength,-distfrommid) %>%
  mutate(cor.first = ifelse(response1==correctR, 1, 0), # did they get it right on the first trial
         prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), # yesterday and tomorrow coded as proximal terms
         prox = as.factor(prox))


cal.sum <- cal.d %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "aftertomorrow","yesterday","tomorrow"))) %>% #for each word, how many kids got them right on the first try
   group_by(language, agegroup, item) %>%
  summarize(first.m = mean(cor.first, na.rm=T),     # % who put item in right box on first try
            sd.correct = sd(cor.first, na.rm=T),
            n = n(),
            se.correct = sd.correct/sqrt(n),
            deictic.m = mean(stat.correct), # % who got correct status (final answer)
            rank.m = mean(correct))  # right box (final answer)
```


Calendar task only: Frequency distribution of box placement for each time word
```{r}
#filter by language
cal.e <- cal.d %>%
  filter(language == "english") %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

cal.g <- cal.d %>%
  filter(language == "german") %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

cal.d %>%
  mutate(item = factor(item, levels = c("beforeyesterday", "yesterday", "tomorrow", "aftertomorrow")))

all <- ggplot(cal.d, aes(x = response1)) +
  geom_histogram(position = "identity", colour = "grey40", alpha = 0.2, binwidth = 1) +
  xlab("box placement") +
  ggtitle("English Speakers") +
  ylim(0, 30) +
  facet_grid(language ~ item ~ agegroup)
all
  
#Frequency distributions of first response only
par(mfrow=c(1,1))
E <- ggplot(cal.e, aes(x=response1)) +
  geom_histogram(position = "identity", colour = "grey40", alpha = 0.2, binwidth = 1) +
  xlab("box placement") +
  ggtitle("English Speakers") +
  ylim(0, 40) +
  facet_grid(item ~ agegroup)
E

G <- ggplot(cal.g, aes(x=response1)) +
  geom_histogram(position ="identity", colour = "grey40", alpha = 0.2, binwidth = 1) +
  xlab("box placement") +
  ggtitle("German Speakers") +
  ylim(0, 40) +
  facet_grid(item ~ agegroup)
G

histograms <- ggarrange(E, G, 
          ncol = 1, nrow = 2)

histograms

ggsave(histograms, file= "BoxPlacementByItem.jpeg", width = 10, height = 12, dpi = 300)
```
Calendar Task: does language spoken or age (in years) predict successful placement of time words in the correct squares on the first try?
```{r}
cal.lm1 <- glmer(cor.first ~ language*item*ageyears + (1|subjid), family = 'binomial', data=cal.d) #FTC
summary(cal.lm1) 
Anova(cal.lm1, Type=3) # suggests there are effects of language, item, and ageyears with no interactions

cal.lm2 <- glmer(cor.first ~ language + item + ageyears + (1|subjid), family = 'binomial', data=cal.d) 
summary(cal.lm2)
Anova(cal.lm2, Type=3)


cal.lm3 <-  glmer(cor.first ~ language*prox*ageyears + (1|subjid), family='binomial', data=cal.d) #FTC
summary(cal.lm3)
Anova(cal.lm3, Type=3) # suggests main effects of language, proximity, and age with no interactions

cal.lm4 <-  glmer(cor.first ~ language + prox + ageyears + (1|subjid), family='binomial', data=cal.d) 
summary(cal.lm4)
Anova(cal.lm4, Type=3)

```

Calendar Task: does item or age (in years) predict successful placement of time words in the correct squares on the first try?

Mixed-effects logistic regression examining the effects of age, and item on successful placement of time words in the correct squares on the first try [English participants only]
```{r}
#English participants only
cal.lm.e1 = glmer(cor.first ~ item*ageyears + (1|subjid), family='binomial', data=cal.e)
summary(cal.lm.e1)
Anova(cal.lm.e1, Type=3) #suggests main effects, no interaction

cal.lm.e2 = glmer(cor.first ~ item + ageyears + (1|subjid), family='binomial', data=cal.e)
summary(cal.lm.e2)
Anova(cal.lm.e2, Type=3)

#German participants only
cal.lm.g1 = glmer(cor.first ~ item*ageyears + (1|subjid), family='binomial', data=cal.g)
summary(cal.lm.g1)
Anova(cal.lm.g1, Type=3)

cal.lm.g2 = glmer(cor.first ~ item + ageyears + (1|subjid), family='binomial', data=cal.g)
summary(cal.lm.g2)
Anova(cal.lm.g2, Type=3)


```

Calendar Task: does language spoken, item, or age (in years) predict successful placement of time words in the past or the future?
```{r}
d.lm1 <- glmer(stat.correct ~ language*item*ageyears + (1|subjid), family = 'binomial', data=cal.d) #FTC
summary(d.lm1) 
Anova(d.lm1, Type=3) # suggests there are effects of item but not ageyears or language (and with no interactions)

d.lm2 <- glmer(stat.correct ~ language + item + ageyears + (1|subjid), family = 'binomial', data=cal.d) 
summary(d.lm2)
Anova(d.lm2, Type=3) # suggests there are effects of item but not ageyears or language (and with no interactions)


d.lm3 <-  glmer(stat.correct ~ language*prox*ageyears + (1|subjid), family='binomial', data=cal.d) #FTC
summary(d.lm3)
Anova(d.lm3, Type=3) # suggests there are no main effects of language, proximity, or age and no interactions

d.lm4 <-  glmer(stat.correct ~ language + prox + ageyears + (1|subjid), family='binomial', data=cal.d) 
summary(d.lm4)
Anova(d.lm4, Type=3)
```


Mixed-effects logistic regression examining the effects of language group, age, and temporal location (proximal vs. distal) on children’s likelihood of correctly identifying the deictic status of time words. 
```{r}
d.lm5 = glmer(stat.correct ~ language*prox+ageyears*prox + (1|subjid), family='binomial', data=cal.d) #FTC
summary(d.lm5)
Anova(d.lm5, Type=3) #suggests no main effects of language, proximity, age in years, and no interactions

d.lm6 = glmer(stat.correct ~ language + prox + ageyears + (1|subjid), family = 'binomial', data=cal.d)
summary(d.lm6)
Anova(d.lm6, Type=3)
```
Calendar Task: does language spoken or age (in years) predict successful placement of time words in the past or the future?

Mixed-effects logistic regression examining the effects of age, and item ('day before yesterday', 'yesterday', 'tomorrow', 'day after tomorrow') on children’s likelihood of correctly identifying the deictic status of time words. 
```{r}
#English participants only
d.lm.e1 = glmer(stat.correct ~ item*ageyears + (1|subjid), family='binomial', data=cal.e) #FTC
summary(d.lm.e1) #suggests main effect of item but no interaction
Anova(d.lm.e1, Type=3)

d.lm.e2 = glmer(stat.correct ~ item + ageyears + (1|subjid), family = 'binomial', data=cal.e)
summary(d.lm.e2)
Anova(d.lm.e2, Type = 3)

#German participants only
d.lm.g1 = glmer(stat.correct ~ item*ageyears + (1|subjid), family='binomial', data=cal.g) #FTC
summary(d.lm.g1) # suggests main effect of item but no interaction
Anova(d.lm.g1, Type = 3)

d.lm.g2 = glmer(stat.correct ~ item + ageyears + (1|subjid), family='binomial', data=cal.g)
summary(d.lm.g2)
Anova(d.lm.g2, Type = 3)
```

```{r}
#-language:prox:ageyears 
verbal <- d.all %>%
  filter(itemtype=="verbal" & agegroup %in% c('4','5') & item=="daysofweek") %>%
  group_by(language, item) %>%
  summarize(correct.m <- mean(correct))

### plot correct first placements (Did they give correct response first time)
correctPlacements <- ggplot(data=cal.sum, aes(x=agegroup, y=first.m, group=language, color=language)) +
  geom_line(aes(color=language))+
  geom_point() +
  ylab('prop correct') +
  ylim(0,1) +
  #geom_errorbar(aes(ymin=first.m-se.correct, ymax=first.m+se.correct), width=.2, position=position_dodge(.05)) +
facet_wrap( ~ item, nrow=2) 
correctPlacements
ggsave(correctPlacements, file= "CorrectFirstPlacements.jpeg", width = 10, height = 10, dpi = 300)

### plot correct first placements separately for each language group
Englishcal_sum <- cal.sum %>%
  filter(language == "english")
Germancal_sum <- cal.sum %>%
  filter(language == "german")

EnglishPlacements <- ggplot(data = Englishcal_sum, aes(x=agegroup, y = first.m, group = item, color = item)) +
  geom_line(aes(color=item)) +
  geom_point() +
  ylab('prop correct') +
  ylim(0,1)
EnglishPlacements

GermanPlacements <- ggplot(data=Germancal_sum, aes(x=agegroup, y = first.m, group = item, color = item)) +
  geom_line(aes(color=item)) +
  geom_point() +
  ylab('prop correct') +
  ylim(0,1)
GermanPlacements

CorrectFirstFigure <- ggarrange(EnglishPlacements, GermanPlacements,
                    labels = c("English", "German"),
                    ncol = 2, nrow = 1)
CorrectFirstFigure
```
```{r}
### plot correct status
correctStatus <- ggplot(data=cal.sum, aes(x=agegroup, y=deictic.m, group=language, color=language)) +
  geom_line(aes(color=language))+
  geom_point() +
  ylab('prop correct') +
  ylim(0,1) +
  #geom_errorbar(aes(ymin=first.m-se.correct, ymax=first.m+se.correct), width=.2, position=position_dodge(.05)) +
  facet_wrap( ~ item, nrow=2) 
correctStatus
ggsave(correctStatus, file= "correctStatus.jpeg", width = 10, height = 10, dpi = 300)

### plot correct status by item (for each language separately)
EnglishStatus <- ggplot(data=Englishcal_sum, aes(x=agegroup, y=deictic.m, group=item, color=item)) +
  geom_line(aes(color=item))+
  geom_point() +
  ylab('prop correct') +
  ylim(0,1)
EnglishStatus

GermanStatus <-ggplot(data=Germancal_sum, aes(x=agegroup, y=deictic.m, group=item, color=item)) +
  geom_line(aes(color=item))+
  geom_point() +
  ylab('prop correct') +
  ylim(0,1)
GermanStatus

CorrectStatusFigure <- ggarrange(EnglishStatus, GermanStatus,
                    labels = c("English", "German"),
                    ncol = 2, nrow = 1)
CorrectStatusFigure

## check on bizarre results: English speaking older kids are doing worse with yesterday and tomorrow than the younger ones
Englishcal_sum%>%
  group_by(item, agegroup) %>%
  summarize(mean(deictic.m))
cal.e %>%
  group_by(item, agegroup) %>%
  summarize(mean(stat.correct))
```
#What are errors based on? distance from today?
#first.m = mean(cor.first, na.rm=T),     # average # of participants who put item in right box on first try
            #sd.correct = sd(cor.first, na.rm=T),
            #se.correct = sd.correct/sqrt(n),
            #deictic.m = mean(stat.correct), # average #participants who got correct status
            
###Did children place paired distal, proximal, past, and future items in the correct location? (e.g., correct placement for both tomorrow/after tomorrow)
```{r}
#create new data frame
cal.allT <- cal.d %>%
  select (subjid, agegroup, language, item, correct)
#transpose item (i.e., transform from long to wide format)
cal.allT <- reshape(cal.allT, idvar = c("subjid", "agegroup", "language"), timevar = "item", direction = "wide")

#Code for tomorrow & yesterday both correct (proxCorr = 1)
cal.allT <- cal.allT %>%
  mutate(proxCorr = case_when(correct.tomorrow == "1" & correct.yesterday == "1" ~ 1, TRUE ~ 0)) %>%
#Code for after tomorrow & before yesterday both correct (distCorr = 1)
  mutate(distCorr = case_when(correct.aftertomorrow == "1" & correct.beforeyesterday == "1" ~ 1, TRUE ~ 0)) %>%
#Code for tomorrow & after tomorrow correct (tomorrow2Corr = 1)
  mutate(tomorrow2Corr = case_when(correct.tomorrow == "1" & correct.aftertomorrow == "1" ~ 1, TRUE ~ 0)) %>%
#Code for yesterday & before yesterday correct (yesterday2Corr = 1)
  mutate(yesterday2Corr = case_when(correct.yesterday == "1" & correct.beforeyesterday == "1" ~ 1, TRUE ~ 0))

#create new data frame (again) and transpose from wide format back to long format
cal.allTrecoded <- cal.allT %>%
  select(subjid, agegroup, language, proxCorr, distCorr, tomorrow2Corr, yesterday2Corr)
cal.allTrecoded <- reshape(cal.allTrecoded,
                           idvar = "subjid", 
                           varying = list(c(4, 5, 6, 7)), 
                           direction = "long", 
                           v.names = c('BothCorr'), 
                           timevar = "Pair")
#rename values in 'Pair' variable column
cal.allTrecoded <- cal.allTrecoded %>%
  mutate(Pair = as.factor(Pair), 
         item = recode_factor(Pair, '1' = 'proxCorr', 
                              '2' = 'distCorr', 
                              '3' = 'tomorrow2Corr', 
                              '4' = 'yesterday2Corr'))

#counts just to make sure data was transposed correctly (without error)
#counts for wide data frame (English Ps only)
#proxCorr_countsWide <- cal.allT %>%
  #filter(language == "english") %>%
  #group_by(agegroup, proxCorr) %>%
  #summarise(Freq=n())
#distCorr_countsWide <- cal.allT %>%
  #filter(language == "english") %>%
  #group_by(agegroup,distCorr) %>%
  #summarise(Freq=n())
#tomorrow2Corr.countsWide <- cal.allT %>%
  #filter(language == "english") %>%
  #group_by(agegroup, tomorrow2Corr) %>%
  #summarise(Freq=n())
#yesterday2Corr.countsWide <- cal.allT %>%
  #filter(language == "english") %>%
  #group_by(agegroup, yesterday2Corr) %>%
  #summarise(Freq=n())

#counts for long data frame
#proxCorr_countsLong <- cal.allTrecoded %>%
  #filter(language == "english", item == "proxCorr") %>%
  #group_by(agegroup, BothCorr) %>%
  #summarise(Freq=n())
#distCorr_countsLong <- cal.allTrecoded %>%
  #filter(language == "english", item == "distCorr") %>%
  #group_by(agegroup, BothCorr) %>%
  #summarise(Freq=n())
#tomorrow2corr_countsLong <- cal.allTrecoded %>%
  #filter(language == "english", item == "tomorrow2Corr") %>%
  #group_by(agegroup, BothCorr) %>%
  #summarise(Freq=n())
#yesterday2Corr_countsLong <- cal.allTrecoded %>%
  #filter(language == "english", item == "yesterday2Corr") %>%
  #group_by(agegroup, BothCorr) %>%
  #summarise(Freq=n())

###plot number of participants who answered pairs of questions correctly: distal Qs, proximal Qs, tomorrow/after tomorrow Qs, yesterday/before yesterday Qs.
ggplot(cal.allTrecoded, aes(x=BothCorr)) +
  geom_histogram(position = "identity", colour = "grey40", alpha = 0.2, binwidth = 0.5) +
  xlab("1 = both correct") +
  facet_grid(item ~ agegroup)
ggplot(data=cal.allTrecoded, aes(x = BothCorr)) +
  geom_bar() +
  geom_text(stat='count', aes(label = ..count..), vjust = -1) +
  facet_wrap(language ~ item, nrow = 4)

###plot proportion of participants who answered pairs of questions correctly: distal Qs, proximal Qs, tomorrow Qs, yesterday Qs.
##1 = both correct, 0 = one or more incorrect responses for paired stimuli (e.g., tomorrow & day after tomorrow)
cal.allTrecoded[,'BothCorrF'] <- as.factor(cal.allTrecoded[,'BothCorr'])
Prop_Graph <- ggplot(cal.allTrecoded, aes(x=item, fill = BothCorrF)) +
  geom_bar(position = "fill") +
  coord_flip() +
  ylab('proportion of participants') +
  facet_wrap(language ~ agegroup)


cal.sumPairs <- cal.allTrecoded %>%
#for each word, how many kids got them right on the first try
   group_by(language, agegroup, item) %>%
  summarize(bothcorrect.m = mean(BothCorr, na.rm=T),     # % who put item in right box on first try
            sd.bothcorrect = sd(BothCorr, na.rm=T),
            n = n(),
            se.bothcorrect = sd.bothcorrect/sqrt(n))

### plot if paired items both correct (correct response first time)
CorrectPairs <- ggplot(data=cal.sumPairs, aes(x=agegroup, y=bothcorrect.m, group=language, color=language)) +
  geom_line(aes(color=language))+
  geom_point() +
  ylab('prop correct') +
  ylim(0,1) +
  #geom_errorbar(aes(ymin=first.m-se.correct, ymax=first.m+se.correct), width=.2, position=position_dodge(.05)) +
facet_wrap( ~ item, nrow=2) 
CorrectPairs

ggsave(CorrectPairs, file= "PairedItems_PropCorrect.jpeg", width = 10, height = 10, dpi = 300)

#plot if paired items both placed correctly on the first try (for each language separately)
Englishcal.sumPairs <- cal.sumPairs %>%
  filter(language == "english")

Germancal.sumPairs <- cal.sumPairs %>%
  filter(language == "german")

CorrectPairsEnglish <- ggplot(data=Englishcal.sumPairs, aes(x = agegroup, y =bothcorrect.m, group=item, color=item)) +
  geom_line(aes(color = item)) +
  geom_point() +
  ylab('prop correct') +
  ylim(0, 1)
CorrectPairsEnglish

CorrectPairsGerman <- ggplot(data=Germancal.sumPairs, aes(x = agegroup, y =bothcorrect.m, group=item, color=item)) +
  geom_line(aes(color = item)) +
  geom_point() +
  ylab('prop correct') +
  ylim(0, 1)

CorrectPairsFigure <- ggarrange(CorrectPairsEnglish, CorrectPairsGerman,
                    labels = c("English", "German"),
                    ncol = 2, nrow = 1)
CorrectPairsFigure
```
```{r}
#compare performance between time words (within each language separately)
ggboxplot(Englishcal_sum, x = "item", y = "first.m",
          color = "item",
          ylab = "% who put item in right box on first try", xlab = "items", 
          ylim=c(0.2, 1.0)) +
  ggtitle("English Speakers")

ggboxplot(Germancal_sum, x = "item", y = "first.m",
          color = "item",
          ylab = "% who put item in right box on first try", xlab = "items", 
          ylim=c(0.2, 1.0)) +
  ggtitle("German Speakers")

#wilcox_test for item level comparisons
English.test <- cal.e %>%
  wilcox_test(cor.first ~ item) %>%
  add_significance()
English.test

German.test <- cal.g %>%
  wilcox_test(cor.first ~ item) %>%
  add_significance()
German.test
```

```{r}
#compare performance between time words by age group (within each language separately)
English_boxplot <- ggboxplot(Englishcal_sum, x = "item", y = "first.m",
          color = "item", 
          ylab = "% who put item in right box on first try", xlab = "items",
          ylim=c(0, 1.0),
          facet.by = "agegroup",
          nrow = 3,
          ncol = 1) +
  ggtitle("English Speakers")
English_boxplot
ggsave(English_boxplot, file= "EnglishBoxPlot.jpeg", width = 12, height = 10, dpi = 300)

German_boxplot <- ggboxplot(Germancal_sum, x = "item", y = "first.m",
          color = "item", 
          ylab = "% who put item in right box on first try", xlab = "items",
          ylim=c(0, 1.0),
          facet.by = "agegroup",
          nrow = 3,
          ncol = 1) +
  ggtitle("German Speakers")
German_boxplot
ggsave(German_boxplot, file= "GermanBoxPlot.jpeg", width = 12, height = 10, dpi = 300)

#wilcox_test for item level comparisons
English.test <- cal.e %>%
  group_by(agegroup) %>%
  wilcox_test(cor.first ~ item) %>%
  add_significance()
English.test

German.test <- cal.g %>%
  group_by(agegroup) %>%
  wilcox_test(cor.first ~ item) %>%
  add_significance()
German.test
```


##Did kids who answered verbal Qs correctly also answer Deictic Qs correctly?
```{r}
#create new data frame
target <- c("verbal", "deictic")
VerbalCal.d <- d.all %>%
  filter(task=="calendar" & itemtype == target & agegroup %in% c('4','5','6') & ageyears<7.0) %>% #filter only calendar items that are marked as deictic and verbal items
  select(-linelength,-distfrommid) %>%
  mutate(cor.first = ifelse(response1==correctR, 1, 0), #did they get it right on the first trial
         prox = ifelse(itemtype == "deictic" & item %in% c('yesterday','tomorrow'),1, NA),#yesterday&tomorrow coded as proximal terms
         distal = ifelse(itemtype == "deictic" & item %in% c('beforeyesterday', 'aftertomorrow'),0, NA),#beforeyesterday%aftertomorrow coded as distal terms
         prox = as.factor(prox), 
         distal = as.factor(distal))

#create new data frame (verbal items only)
VerbalT.d <- VerbalCal.d %>%
  filter(itemtype == "verbal") %>%
  select (subjid, agegroup, language, task, item, itemtype, correct, cor.first)
  
#transpose item (i.e., transform from long to wide format)
VerbalT.d <- reshape(VerbalT.d, idvar = c("subjid", "agegroup", "language"), timevar = "item", direction = "wide")
```
#check percentage of particiopants (in each language group separately) that were able to correctly recite the days of the week
```{r}
daysofweek <- d.all %>%
  select(-weekday, -ageyears, -order, -itemnum, -timelinefirst, -task, -linenum, -itemtype, -linelength, -distfrommid, -response2, -prompts, -item.stat, -stat.correct) %>%
  filter(item == "daysofweek")

German_daysofweek <- d.all %>%
  filter(language == "german", item == "daysofweek", exclude == "0") %>%
  select(subjid, agegroup, correct) %>%
  group_by(correct, agegroup) %>%
  summarise(n())

English_daysofweek <- d.all %>%
  filter(language == "english", item == "daysofweek", exclude == "0") %>%
  select(subjid, agegroup, correct) %>%
  group_by(correct, agegroup) %>%
  summarise(n())
```


##use verbal Q's to predict deictic Q's performance [split kids by if they recited days of week or not]

#Mixed-effects logistic regression examining the effects of age, and verbal Qs on children’s successful placement of time words in the correct squares on the first try
```{r}
#create new data frame (english only)
#vd.e <- d.all %>%
  #filter(language == 'english', task=="calendar" & itemtype %in% c("deictic", "verbal") & agegroup %in% c('4','5','6') & ageyears<7.0) %>% #filter only calendar items that are marked as deictic (verbal items not involved in the calendar task)
  #select(-linelength,-distfrommid) %>%
  #mutate(#response = ifelse(is.na(response2) == T, response1, response2), #this is redundant
         #response = as.numeric(response), #this is redundant 
         #cor.first = ifelse(response1==correctR, 1, 0), #did they get it right on the first trial
         #prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), #yesterday and tomorrow coded as proximal terms
         #prox = as.factor(prox))

#English participants only
#vd.lm.e = glmer(correct ~ itemtype*ageyears + (1|subjid), family='binomial', data=vd.e)
#summary(vd.lm.e)

#create new data frame (german only)
#vd.g <- d.all %>%
   #filter(language == 'german', task=="calendar" & itemtype %in% c("deictic", "verbal") & agegroup %in% c('4','5','6') & ageyears<7.0) %>% #filter only calendar items that are marked as deictic (verbal items not involved in the calendar task)
  #select(-linelength,-distfrommid) %>%
  #mutate(#response = ifelse(is.na(response2) == T, response1, response2), #this is redundant
         #response = as.numeric(response), #this is redundant 
         #cor.first = ifelse(response1==correctR, 1, 0), #did they get it right on the first trial
         #prox = ifelse(item %in% c('yesterday','tomorrow'),1,0), #yesterday and tomorrow coded as proximal terms
         #prox = as.factor(prox))
#German participants only
#vd.lm.g = glmer(cor.first ~ itemtype + ageyears + (1|subjid), family='binomial', data=vd.g)
#summary(vd.lm.g)
```

##Sum # of words correct (4 correct? 3 correct? etc.)
